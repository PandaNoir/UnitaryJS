// Generated by CoffeeScript 1.9.1
(function() {
  "use strict";
  var BaseVector, Circle, Graph, Image_, Line, Module, Point, Polygon, Quadrilateral, Rect, Segment, Text_, Triangle, UnitaryObject, Vector, Vector3D, XAxis, YAxis, _global, distance, gcd,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  gcd = function(m, n) {
    if (m < n) {
      return gcd(n, m);
    }
    if (m < 0) {
      return gcd(-m, n);
    }
    if (n < 0) {
      return gcd(m, -n);
    }
    if (n === 0) {
      return m;
    }
    return gcd(n, m % n);
  };

  distance = function(A, B) {
    var res;
    if (A instanceof Point && B instanceof Point) {
      return Math.sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
    }
    if (A instanceof Point && B instanceof Line) {
      res = B.a * A.x + B.b * A.y + B.c;
      if (res < 0) {
        res *= -1;
      }
      res /= Math.sqrt(B.a * B.a + B.b * B.b);
      return res;
    }
    if (A instanceof Line && B instanceof Point) {
      return distance(B, A);
    }
  };

  UnitaryObject = (function() {
    function UnitaryObject() {
      if (!(this instanceof UnitaryObject)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      this.style = {
        fillColor: null,
        strokeColor: null
      };
    }

    UnitaryObject.prototype.equals = function(B) {
      return this.name() === B.name();
    };

    UnitaryObject.prototype.setFillColor = function(color) {
      this.style.fillColor = color;
      return this;
    };

    UnitaryObject.prototype.setStrokeColor = function(color) {
      this.style.strokeColor = color;
      return this;
    };

    UnitaryObject.prototype.setStyle = function(style) {
      var key;
      this.style = {};
      for (key in style) {
        this.style[key] = style[key];
      }
      return this;
    };

    UnitaryObject.prototype.moveX = function(dx) {
      return this.move(dx, 0);
    };

    UnitaryObject.prototype.moveY = function(dy) {
      return this.move(0, dy);
    };

    UnitaryObject.prototype.name = function() {
      return 'UnitaryObject';
    };

    return UnitaryObject;

  })();

  Point = (function(superClass) {
    extend(Point, superClass);

    function Point(x, y) {
      if (!(this instanceof Point)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      Point.__super__.constructor.call(this);
      this.x = x;
      this.y = y;
    }

    Point.prototype.moveTo = function(x, y) {
      return new Point(x, y).setStyle(this.style);
    };

    Point.prototype.move = function(dx, dy) {
      return new Point(this.x + dx, this.y + dy).setStyle(this.style);
    };

    Point.prototype.toString = function() {
      return '(' + this.x + ', ' + this.y + ')';
    };

    Point.prototype.inspect = function() {
      return '(' + this.x + ', ' + this.y + ')';
    };

    Point.prototype.equals = function(B) {
      if (!Point.__super__.equals.call(this, B)) {
        return false;
      }
      return this.x === B.x && this.y === B.y;
    };

    Point.prototype.name = function() {
      return 'Point';
    };

    return Point;

  })(UnitaryObject);

  BaseVector = (function(superClass) {
    extend(BaseVector, superClass);

    function BaseVector() {
      var _i, i;
      BaseVector.__super__.constructor.call(this);
      if (arguments.length === 1 && Object.prototype.toString.call(arguments[0]) === '[object Array]') {
        this.component = new Array(arguments[0].length);
        i = 0;
        _i = arguments[0].length;
        while (i < _i) {
          this.component[i] = arguments[0][i];
          i = 0 | i + 1;
        }
      } else {
        this.component = new Array(arguments.length);
        i = 0;
        _i = arguments.length;
        while (i < _i) {
          this.component[i] = arguments[i];
          i = 0 | i + 1;
        }
      }
    }

    BaseVector.prototype.add = function(CD) {
      var component, i, j, len, ref, val;
      if (this.component.length !== CD.component.length) {
        throw new Error('dimention of each vector are different.');
      }
      component = new Array(this.component.length);
      ref = this.component;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        val = ref[i];
        component[i] = val + CD.component[i];
      }
      return new BaseVector(component);
    };

    BaseVector.prototype.minus = function(CD) {
      return this.add(CD.multiple(-1));
    };

    BaseVector.prototype.product = function(CD) {
      var i, j, len, product, ref, val;
      if (this.component.length !== CD.component.length) {
        throw new Error('dimention of each vector are different.');
      }
      product = 0;
      ref = this.component;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        val = ref[i];
        product += val * CD.component[i];
      }
      return product;
    };

    BaseVector.prototype.multiple = function(k) {
      var component, n;
      component = (function() {
        var j, len, ref, results;
        ref = this.component;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push(k * n);
        }
        return results;
      }).call(this);
      return new BaseVector(component);
    };

    BaseVector.prototype.abs = function() {
      var component, j, len, n, res;
      component = (function() {
        var j, len, ref, results;
        ref = this.component;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push(n * n);
        }
        return results;
      }).call(this);
      res = 0;
      for (j = 0, len = component.length; j < len; j++) {
        n = component[j];
        res += n;
      }
      return Math.sqrt(res);
    };

    BaseVector.prototype.equals = function(B) {
      var i, j, len, ref, val;
      if (this.component.length !== B.component.length) {
        return false;
      }
      ref = this.component;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        val = ref[i];
        if (val !== B.component[i]) {
          return false;
        }
      }
      return true;
    };

    BaseVector.prototype.move = function() {
      var arr, i, j, len, val;
      arr = new Array(arguments.length);
      for (i = j = 0, len = arguments.length; j < len; i = ++j) {
        val = arguments[i];
        arr[i] = val;
      }
      return this.add.apply(this, new BaseVector(arr));
    };

    BaseVector.prototype.name = function() {
      return 'BaseVector';
    };

    return BaseVector;

  })(UnitaryObject);

  Vector = (function(superClass) {
    extend(Vector, superClass);

    function Vector() {
      if (!(this instanceof Vector)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      if (arguments.length === 2) {
        Vector.__super__.constructor.call(this, arguments[0], arguments[1]);
        this.x = arguments[0];
        this.y = arguments[1];
      } else if (arguments.length === 1) {
        Vector.__super__.constructor.call(this, arguments[0].x, arguments[0].y);
        this.x = arguments[0].x;
        this.y = arguments[0].y;
      }
    }

    Vector.prototype.add = function(CD) {
      var newVector;
      newVector = Vector.__super__.add.call(this, CD);
      return new Vector(newVector.component[0], newVector.component[1]);
    };

    Vector.prototype.minus = function(CD) {
      var newVector;
      newVector = Vector.__super__.minus.call(this, CD);
      return new Vector(newVector.component[0], newVector.component[1]);
    };

    Vector.prototype.multiple = function(k) {
      var newVector;
      newVector = Vector.__super__.multiple.call(this, k);
      return new Vector(newVector.component[0], newVector.component[1]);
    };

    Vector.prototype.move = function(dx, dy) {
      return new Vector(this.x + dx, this.y + dy);
    };

    Vector.prototype.name = function() {
      return 'Vector';
    };

    return Vector;

  })(BaseVector);

  Vector3D = (function(superClass) {
    extend(Vector3D, superClass);

    function Vector3D() {
      if (!(this instanceof Vector3D)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      if (arguments.length === 3) {
        Vector3D.__super__.constructor.call(this, arguments[0], arguments[1], arguments[2]);
        this.x = arguments[0];
        this.y = arguments[1];
        this.z = arguments[2];
      } else if (arguments.length === 1) {
        Vector3D.__super__.constructor.call(this, arguments[0].x, arguments[0].y, arguments[0].z);
        this.x = arguments[0].x;
        this.y = arguments[0].y;
        this.z = arguments[0].z;
      }
    }

    Vector3D.prototype.add = function(CD) {
      var newVector;
      newVector = Vector3D.__super__.add.call(this, CD);
      return new Vector3D(newVector.component[0], newVector.component[1], newVector.component[2]);
    };

    Vector3D.prototype.minus = function(CD) {
      var newVector;
      newVector = Vector3D.__super__.minus.call(this, CD);
      return new Vector3D(newVector.component[0], newVector.component[1], newVector.component[2]);
    };

    Vector3D.prototype.multiple = function(k) {
      var newVector;
      newVector = Vector3D.__super__.multiple.call(this, k);
      return new Vector3D(newVector.component[0], newVector.component[1], newVector.component[2]);
    };

    Vector3D.prototype.move = function(dx, dy, dz) {
      return new Vector3D(this.x + dx, this.y + dy, this.z + dz);
    };

    Vector3D.prototype.name = function() {
      return 'Vector3D';
    };

    return Vector3D;

  })(BaseVector);

  Line = (function(superClass) {
    extend(Line, superClass);

    function Line(A, B) {
      var g;
      if (!(this instanceof Line)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      if (A.equals(B)) {
        throw new Error('A equals B. So AB couldn\'t construct line.');
      }
      Line.__super__.constructor.call(this);
      this.points = [A, B];
      this.a = B.y - A.y;
      this.b = A.x - B.x;
      this.c = A.x * (A.y - B.y) - A.y * (A.x - B.x);
      g = gcd(gcd(this.a, this.b), this.c);
      this.a /= g;
      this.b /= g;
      this.c /= g;
      if (this.a === 0) {
        this.c /= this.b;
        this.b = 1;
      }
      if (this.b === 0) {
        this.c /= this.a;
        this.a = 1;
      }
    }

    Line.prototype.move = function(dx, dy) {
      return new Line(this.points[0].move(dx, dy), this.points[1].move(dx, dy)).setStyle(this.style);
    };

    Line.prototype.toString = function() {
      var res;
      res = '';
      if (this.a > 0 && this.a !== 1) {
        res += '+' + this.a + 'x';
      }
      if (this.a === 1) {
        res += '+x';
      }
      if (this.a < 0 && this.a !== -1) {
        res += '-' + -this.a + 'x';
      }
      if (this.a === -1) {
        res += '-x';
      }
      if (this.b > 0 && this.b !== 1) {
        res += '+' + this.b + 'y';
      }
      if (this.b === 1) {
        res += '+y';
      }
      if (this.b < 0 && this.b !== -1) {
        res += '-' + -this.b + 'y';
      }
      if (this.b === -1) {
        res += '-y';
      }
      if (this.c > 0) {
        res += '+' + this.c;
      }
      if (this.c < 0) {
        res += '-' + -this.c;
      }
      if (res.charAt(0) === '+') {
        res = res.slice(1);
      }
      return res + '=0';
    };

    Line.prototype.inspect = function() {
      var res;
      res = '';
      if (this.a > 0 && this.a !== 1) {
        res += '+' + this.a + 'x';
      }
      if (this.a === 1) {
        res += '+x';
      }
      if (this.a < 0 && this.a !== -1) {
        res += '-' + -this.a + 'x';
      }
      if (this.a === -1) {
        res += '-x';
      }
      if (this.b > 0 && this.b !== 1) {
        res += '+' + this.b + 'y';
      }
      if (this.b === 1) {
        res += '+y';
      }
      if (this.b < 0 && this.b !== -1) {
        res += '-' + -this.b + 'y';
      }
      if (this.b === -1) {
        res += '-y';
      }
      if (this.c > 0) {
        res += '+' + this.c;
      }
      if (this.c < 0) {
        res += '-' + -this.c;
      }
      if (res.charAt(0) === '+') {
        res = res.slice(1);
      }
      return res + '=0';
    };

    Line.prototype.getIntersection = function(CD) {
      var x, y;
      if (this.a === CD.a && this.b === CD.b) {
        return false;
      }
      y = (CD.a * this.c - this.a * CD.c) / (this.a * CD.b - CD.a * this.b);
      x = -1 * (this.b * y + this.c) / this.a;
      return new Point(x, y);
    };

    Line.prototype.equals = function(CD) {
      if (!Line.__super__.equals.call(this, CD)) {
        return false;
      }
      return this.a === CD.a && this.b === CD.b && this.c === CD.c;
    };

    Line.prototype.name = function() {
      return 'Line';
    };

    return Line;

  })(UnitaryObject);

  Segment = (function(superClass) {
    extend(Segment, superClass);

    function Segment(A, B) {
      if (!(this instanceof Segment)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      if (A.x > B.x) {
        this.points = [B, A];
      } else {
        this.points = [A, B];
      }
      Segment.__super__.constructor.call(this);
      this.length = Math.sqrt(Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2));
    }

    Segment.prototype.move = function(dx, dy) {
      return new Segment(this.points[0].move(dx, dy), this.points[1].move(dx, dy)).setStyle(this.style);
    };

    Segment.prototype.has = function(P) {
      var A, B, ref, ref1, ref2;
      A = this.points[0];
      B = this.points[1];
      if ((A.x <= (ref = P.x) && ref <= B.x)) {
        if (A.y <= B.y && (A.y <= (ref1 = P.y) && ref1 <= B.y) || A.y >= B.y && (A.y >= (ref2 = P.y) && ref2 >= B.y)) {
          if ((A.y - B.y) / (A.x - B.x) * P.x === P.y) {
            return true;
          }
        }
      }
      return false;
    };

    Segment.prototype.intersects = function(CD) {
      var intersection, ref;
      intersection = this.toLine().getIntersection(CD.toLine());
      if (intersection === false) {
        return false;
      }
      if ((this.points[0].x <= (ref = intersection.x) && ref <= this.points[1].x)) {
        return true;
      }
      return false;
    };

    Segment.prototype.toLine = function() {
      return new Line(this.points[0], this.points[1]);
    };

    Segment.prototype.equals = function(CD) {
      if (!Segment.__super__.equals.call(this, CD)) {
        return false;
      }
      return this.points[0].equals(CD.points[0]) && this.points[1].equals(CD.points[1]);
    };

    Segment.prototype.name = function() {
      return 'Segment';
    };

    return Segment;

  })(UnitaryObject);

  Circle = (function(superClass) {
    extend(Circle, superClass);

    function Circle(O, radius) {
      if (!(this instanceof Circle)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      Circle.__super__.constructor.call(this);
      this.Origin = O;
      this.r = radius;
    }

    Circle.prototype.moveTo = function(x, y) {
      return new Circle(this.Origin.moveTo(x, y), this.r).setStyle(this.style);
    };

    Circle.prototype.move = function(dx, dy) {
      return new Circle(this.Origin.move(dx, dy), this.r).setStyle(this.style);
    };

    Circle.prototype.equals = function(C) {
      if (!Circle.__super__.equals.call(this, C)) {
        return false;
      }
      return this.Origin.equals(C.Origin) && this.r === C.r;
    };

    Circle.prototype.name = function() {
      return 'Circle';
    };

    return Circle;

  })(UnitaryObject);

  Polygon = (function(superClass) {
    extend(Polygon, superClass);

    function Polygon() {
      var points;
      points = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!(this instanceof Polygon)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      Polygon.__super__.constructor.call(this);
      if (Object.prototype.toString.call(points[0]) === '[object Array]') {
        this.points = points[0];
      } else {
        this.points = points;
      }
    }

    Polygon.prototype.equals = function() {
      return false;
    };

    Polygon.prototype.move = function(dx, dy) {
      var j, len, length, points, ref, val;
      points = [];
      length = 0;
      ref = this.points;
      for (j = 0, len = ref.length; j < len; j++) {
        val = ref[j];
        points[length] = val.move(dx, dy);
        length = 0 | length + 1;
      }
      return new Polygon(points).setStyle(this.style);
    };

    Polygon.prototype.has = function(P) {
      var a, b, before_v, cos, j, len, rad, ref, v;
      before_v = this.points[this.points.length - 1];
      rad = 0;
      ref = this.points;
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        a = new Vector(v).minus(new Vector(P));
        b = new Vector(before_v).minus(new Vector(P));
        cos = a.product(b) / (a.abs() * b.abs());
        rad += Math.acos(cos);
        before_v = v;
      }
      return Math.round(rad / (2 * Math.PI) * 360) === 360;
    };

    Polygon.prototype.name = function() {
      return 'Polygon';
    };

    return Polygon;

  })(UnitaryObject);

  Quadrilateral = (function(superClass) {
    extend(Quadrilateral, superClass);

    function Quadrilateral(A, B, C, D) {
      if (!(this instanceof Quadrilateral)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      if (new Segment(A, D).intersects(new Segment(B, C))) {
        throw new Error('ABCD is not a quadrilateral.');
      }
      if (A.equals(B) || A.equals(C) || A.equals(D) || B.equals(C) || B.equals(D) || C.equals(D)) {
        throw new Error('ABCD is not a quadrilateral.');
      }
      Quadrilateral.__super__.constructor.call(this, A, B, C, D);
    }

    Quadrilateral.prototype.getArea = function() {
      var A, B, C, D, S1, S2, ref;
      ref = this.points, A = ref[0], B = ref[1], C = ref[2], D = ref[3];
      S1 = new Triangle(A, B, C).getArea();
      S2 = new Triangle(A, C, D).getArea();
      return S1 + S2;
    };

    Quadrilateral.prototype.name = function() {
      return 'Quadrilateral';
    };

    return Quadrilateral;

  })(Polygon);

  Triangle = (function(superClass) {
    extend(Triangle, superClass);

    function Triangle(A, B, C) {
      if (!(this instanceof Triangle)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      if ((A == null) || (B == null) || (C == null)) {
        throw new Error('Triangle must have three vertices.');
      }
      if (A.equals(B) || B.equals(C) || A.equals(C)) {
        throw new Error('Triangle must have three vertices.');
      }
      Triangle.__super__.constructor.call(this, A, B, C);
    }

    Triangle.prototype.getCircumcircle = function() {
      var A, AB, B, BC, C, CA, O, R, S, a, b, c, cosA, sinA, vA, vB, vC, vO;
      A = this.points[0];
      B = this.points[1];
      C = this.points[2];
      AB = new Segment(A, B);
      BC = new Segment(B, C);
      CA = new Segment(C, A);
      S = this.getArea();
      vA = new Vector(A.x, A.y);
      vB = new Vector(B.x, B.y);
      vC = new Vector(C.x, C.y);
      a = Math.pow(BC.length, 2);
      b = Math.pow(CA.length, 2);
      c = Math.pow(AB.length, 2);
      vO = new Vector(0, 0).add(vA.multiple(a * (b + c - a))).add(vB.multiple(b * (c + a - b))).add(vC.multiple(c * (a + b - c))).multiple(1 / (16 * (Math.pow(S, 2))));
      O = new Point(vO.x, vO.y);
      cosA = vB.minus(vA).product(vC.minus(vA)) / (AB.length * CA.length);
      sinA = Math.sqrt(1 - Math.pow(cosA, 2));
      R = BC.length / sinA / 2;
      return new Circle(O, R);
    };

    Triangle.prototype.getIncircle = function() {
      var O, a, b, c, r, vA, vB, vC, vO;
      vA = new Vector(this.points[0].x, this.points[0].y);
      vB = new Vector(this.points[1].x, this.points[1].y);
      vC = new Vector(this.points[2].x, this.points[2].y);
      a = vC.minus(vB).abs();
      b = vC.minus(vA).abs();
      c = vB.minus(vA).abs();
      vO = new Vector(0, 0).add(vA.multiple(a / (a + b + c))).add(vB.multiple(b / (a + b + c))).add(vC.multiple(c / (a + b + c)));
      O = new Point(vO.x, vO.y);
      r = 2 * this.getArea() / (a + b + c);
      return new Circle(O, r);
    };

    Triangle.prototype.getArea = function() {
      var A, AB, AC, B, C, S, cosA, sinA, vAB, vAC;
      A = this.points[0];
      B = this.points[1];
      C = this.points[2];
      AB = new Segment(A, B);
      AC = new Segment(A, C);
      vAB = new Vector(B.x - A.x, B.y - A.y);
      vAC = new Vector(C.x - A.x, C.y - A.y);
      cosA = vAB.product(vAC) / (AB.length * AC.length);
      sinA = Math.sqrt(1 - Math.pow(cosA, 2));
      S = AB.length * AC.length * sinA / 2;
      return S;
    };

    Triangle.prototype.name = function() {
      return 'Triangle';
    };

    return Triangle;

  })(Polygon);

  Rect = (function(superClass) {
    extend(Rect, superClass);

    function Rect(A, B) {
      if (!(this instanceof Rect)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      Rect.__super__.constructor.call(this, A, B);
    }

    Rect.prototype.has = function(P) {
      var A, B;
      A = this.points[0];
      B = this.points[1];
      return (A.x - P.x) * (B.x - P.x) <= 0 && (A.y - P.y) * (B.y - P.y) <= 0;
    };

    Rect.prototype.name = function() {
      return 'Rect';
    };

    return Rect;

  })(Polygon);

  Text_ = (function(superClass) {
    extend(Text_, superClass);

    function Text_(str, P, align, maxWidth) {
      if (align == null) {
        align = 'left';
      }
      if (maxWidth == null) {
        maxWidth = null;
      }
      if (!(this instanceof Text_)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      Text_.__super__.constructor.call(this);
      this.P = P;
      this.string = str;
      this.text = str;
      this.strokesOutline = false;
      this.style.align = align;
      this.style.maxWidth = maxWidth;
      this.style.fillColor = '#000';
      this.style.outlineColor = '#000';
      this.style.baseline = 'alphabetic';
      this.style.font = null;
    }

    Text_.prototype.strokeOutline = function() {
      this.strokesOutline = true;
      return this;
    };

    Text_.prototype.setAlign = function(align) {
      this.style.align = align;
      return this;
    };

    Text_.prototype.setOutlineColor = function(color) {
      this.style.outlineColor = color;
      return this;
    };

    Text_.prototype.setBaseline = function(base) {
      this.style.baseline = base;
      return this;
    };

    Text_.prototype.setFont = function(font) {
      this.style.font = font;
      return this;
    };

    Text_.prototype.move = function(dx, dy) {
      var newText;
      newText = new Text_(this.str, this.P.move(dx, dy), this.align, this.maxWidth).setStyle(this.style);
      if (this.strokesOutline) {
        newText.strokeOutline();
      }
      return newText;
    };

    Text_.prototype.name = function() {
      return 'Text';
    };

    return Text_;

  })(UnitaryObject);

  Image_ = (function(superClass) {
    extend(Image_, superClass);

    function Image_(src, startPoint) {
      if (!(this instanceof Image_)) {
        throw new Error('Constructor cannot be called as a function.');
      }
      this.src = src;
      this.startPoint = startPoint;
      this.dx = startPoint.x;
      this.dy = startPoint.y;
      this.dw = null;
      this.dh = null;
      this.sw = null;
      this.sh = null;
      this.sx = null;
      this.sy = null;
    }

    Image_.prototype.trim = function(startPoint, sw, sh, dw, dh) {
      if (dw == null) {
        dw = sw;
      }
      if (dh == null) {
        dh = sh;
      }
      this.sx = startPoint.x;
      this.sy = startPoint.y;
      this.sw = sw;
      this.sh = sh;
      this.dw = dw;
      return this.dh = dh;
    };

    Image_.prototype.resize = function(dw, dh) {
      this.dw = dw;
      return this.dh = dh;
    };

    Image_.prototype.equals = function(B) {
      if (!Image_.__super__.equals.call(this, B)) {
        return false;
      }
      return this.src === B.src && this.dx === B.dx && this.dy === B.dy && this.dw === B.dw && this.dh === B.dh && this.sw === B.sw && this.sh === B.sh && this.sx === B.sx && this.sy === B.sy;
    };

    Image_.prototype.move = function(dx, dy) {
      var newImage;
      newImage = new Image_(this.src, this.startPoint.move(dx, dy));
      if (this.sx !== null) {
        newImage.trim(new Point(this.sx, this.sy), this.sw, this.sh, this.dw, this.dh);
      }
      return newImage;
    };

    Image_.prototype.name = function() {
      return 'Image';
    };

    return Image_;

  })(UnitaryObject);

  Graph = (function(superClass) {
    extend(Graph, superClass);

    function Graph(f, scale) {
      Graph.__super__.constructor.call(this);
      this.f = f;
      this.scale = scale;
      this.start = null;
      this.end = null;
    }

    Graph.prototype.setRange = function(start, end) {
      this.start = start;
      this.end = end;
      return this;
    };

    Graph.prototype.equals = function() {
      return false;
    };

    Graph.prototype.moveX = void 0;

    Graph.prototype.moveY = void 0;

    Graph.prototype.name = function() {
      return 'Graph';
    };

    return Graph;

  })(UnitaryObject);

  XAxis = new Line(new Point(0, 0), new Point(1, 0));

  YAxis = new Line(new Point(0, 0), new Point(0, 1));

  _global = (this || 0).self || global;

  Module = {
    UnitaryObject: UnitaryObject,
    Circle: Circle,
    Graph: Graph,
    Image: Image_,
    Line: Line,
    Point: Point,
    Polygon: Polygon,
    Quadrilateral: Quadrilateral,
    Rect: Rect,
    Segment: Segment,
    Text: Text_,
    Triangle: Triangle,
    Vector: Vector,
    Vector3D: Vector3D,
    XAxis: XAxis,
    YAxis: YAxis,
    distance: distance
  };

  if ('process' in _global) {
    module.exports = Module;
  }

  _global['Unitary'] = Module;

}).call(this);
